/* ***** BEGIN LICENSE BLOCK *****
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Initial Developer of the Original Code is Parakey Inc.
 *
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s):
 *     Joe Hewitt <joe@joehewitt.com>
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 *
 * ***** END LICENSE BLOCK ***** */

#include "nsISupports.idl"

interface jsdIStackFrame;
interface jsdIScript;
interface jsdIValue;
interface nsIDOMWindow;

[scriptable, uuid(c329fbb0-cb7d-11da-a94d-0800200c9a66)]
interface nsIFireBugDebugger : nsISupports
{
  boolean supportsWindow(in nsIDOMWindow window);

  void onLock(in boolean state);

  unsigned long onBreak(in jsdIStackFrame frame);
  unsigned long onHalt(in jsdIStackFrame frame);
  void onCall(in jsdIStackFrame frame);
  void onError(in jsdIStackFrame frame);
  void onResume();

  void onToggleBreakpoint(in string url, in unsigned long lineNo, in boolean isSet);
  void onToggleBreakpointCondition(in string url, in unsigned long lineNo, in boolean isSet);
  void onToggleBreakpointDisabled(in string url, in unsigned long lineNo, in boolean disabled);
  void onToggleErrorBreakpoint(in string url, in unsigned long lineNo, in boolean isSet);
  void onToggleMonitor(in string url, in unsigned long lineNo, in boolean isSet);
};

[scriptable, uuid(35acfa60-d2a0-11da-a94d-0800200c9a66)]
interface nsIFireBugBreakpointCallback : nsISupports
{
    void call(in string url, in unsigned long lineNo, in unsigned long startLineNo, 
        in boolean disabled, in string condition);
};

[scriptable, uuid(61df57e0-4b77-11db-b0de-0800200c9a66)]
interface nsIFireBugClient : nsISupports
{
    void enable();
    void disable();
};

[scriptable, uuid(F71F61B2-CB37-11DA-9B41-B622A1EF5492)]
interface nsIFireBug : nsISupports
{
    const unsigned long STEP_OVER = 1;
    const unsigned long STEP_INTO = 2;
    const unsigned long STEP_OUT = 3;
    
    readonly attribute nsIDOMWindow lastErrorWindow;

    readonly attribute boolean enabled;
    boolean countContext(in boolean on);

    void registerClient(in nsIFireBugClient client);
    void unregisterClient(in nsIFireBugClient client);
    
    void registerDebugger(in nsIFireBugDebugger debugger);
    void unregisterDebugger(in nsIFireBugDebugger debugger);

    /*
     * Lock the debugger so that only one client at a time can use it.
     */
    readonly attribute boolean locked;
    void lockDebugger();
    void unlockDebugger();

    /**
     * Halts execution immediately and calls debugger.onHalt().
     */
    void halt(in nsIFireBugDebugger debugger);
    
    /**
     * Starts stepping when the debugger resumes execution.
     */
    void step(in unsigned long stepMode, in jsdIStackFrame startFrame);
    
    /**
     * Runs until execution hits a particular line when the debugger resumes execution.
     */
    void runUntil(in string url, in unsigned long lineNo, in jsdIStackFrame startFrame);
    
    void setBreakpoint(in string url, in unsigned long lineNo);
    void clearBreakpoint(in string url, in unsigned long lineNo);
    void clearAllBreakpoints(in PRUint32 count, [array, size_is(count)] in string urls);

    void enableBreakpoint(in string url, in unsigned long lineNo);
    void disableBreakpoint(in string url, in unsigned long lineNo);
	boolean isBreakpointDisabled(in string url, in unsigned long lineNo);

	boolean hasBreakpoint(in jsdIScript script);
    void enumerateBreakpoints(in string url, in nsIFireBugBreakpointCallback cb);

	string getBreakpointCondition(in string url, in unsigned long lineNo);
    void setBreakpointCondition(in string url, in unsigned long lineNo, in string condition);

    void setErrorBreakpoint(in string url, in unsigned long lineNo);
    void clearErrorBreakpoint(in string url, in unsigned long lineNo);
	boolean hasErrorBreakpoint(in string url, in unsigned long lineNo);
    void enumerateErrorBreakpoints(in string url, in nsIFireBugBreakpointCallback cb);

    /**
     * Report all calls to the function through the "onCall" callback.
     */
	void monitor(in jsdIScript script, in nsIFireBugDebugger debugger);
	void unmonitor(in jsdIScript script);
	boolean isMonitored(in jsdIScript script);
    void enumerateMonitors(in string url, in nsIFireBugBreakpointCallback cb);

    readonly attribute boolean profiling;
    
    /**
     * Start profiling, or continue profiling if this has already been called.
     * Nested calls are allowed, but each call must be matched with a call to
     * stopProfiling.
     */
	void startProfiling();

    /**
     * Returns the number of milliseconds since profiling began, or -1 if
     * there are still more nested profilers active.
     */
	long stopProfiling();
};

